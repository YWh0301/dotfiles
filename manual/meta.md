# GNU/Linux相关笔记

## 关于我自己的Linux系统的哲学

### 干净 vs 可用

在一个自己可控的系统中追求干净是无可厚非的。因为干净的系统可以使用较少的规则规定系统中的一切，因此我掌控整个系统的时候付出的记忆上的努力便可以较为轻松。然而，这是一个非常理想的情况，因为较少的规则与现代庞大的系统工程实践的现状是相违背的。这并非说系统开发者和应用开发者们都无法和他人进行有效的沟通合作，因为许多时候阻碍人们在规范上进行统一的并不是沟通的能力，而是时间。技术的发展并不真的有什么时间上的余裕，新的需求的发生与新的硬件的发明总是轮流催促软件系统的开发者，导致许多技术平台尚未完善而已经过时。这使得即便是有着极其先进哲学的GNU/Linux这一庞大社区体系中也充斥这各种过时的规范以及杂乱的构建。

在此之上强求干净并无意义。因为我的电脑的最终目的是使用，而不是作为艺术品观赏把玩。更何况在其中把握平衡的很多琐碎的工作其实是由发行版开发人员已经帮忙梳理一遍的，如果真的要事事亲力亲为，其复杂性还会比表面上能看到的要多好几倍。从某种程度上说，如果我需要快速尝试不同的东西，就必须要为了可用性而接受许多软件包的黑盒状态，接受并且欢迎它们可能在我的系统中拉屎，在各处堆放资源与配置、生成进程与服务。

但如果完全地放手，Linux的意义又不存在了。我不希望放弃对于自己的设备的掌控。这是一个永恒的矛盾，而现实就是，并不存在任何银弹方案。Nix显然不是。为了使用软件包而必须先学习一门专用的配置语言是有一些荒谬性在其中的，而其目的又仅仅是“获得可以复现的机器状态”，但我一年会重装几次机器呢？这从付出和收获的两头考虑都有点过于偏执了。

所以我的答案是，我需要为自己维护一个系统文档。我不需要自动化的安装脚本，因为实现这个脚本会有过多的细节要处理，但我需要一个文档来保存信息。在进一步的考虑中我意识到，我所需求的干净的真正含义其实并不是完全的规整或是强迫症般的洁癖，而是在不可避免的熵增中找到信息压缩的方式，并且让实际上有价值的信息并不流失。换句话说，我并不真的介意一个用了十年的机器中有各种各样的屎存在——如果我想要快乐地以各种新的方式使用我的机器而不能做到在一开始就对自己的所有工作流完全确定且永不改变，那这就是不可避免的。但是，我希望我的这个机器的状态可以被重塑，也即，如果我处于某种理由需要重装系统，而我只有这一台电脑，那么我能否把我的所有工作流与设置保存下来。

现阶段我重装机器都需要两台电脑。新的机器中的配置文件需要从老的电脑中一点一点复制过去，如果我没有另外一台电脑，我的配置和工作流就会丢失。不过，对于重要的文件我已经可以胸有成竹地说我不再担心我的电脑上的系统崩溃了，因为使用了同步云存储，所有我的重要的文件都经由pCloud同步，我购买了它永久的1T储存容量。仅存在本地的文件都是我并不在乎丢失与否的文件。而除了文件之外，还有的就是包管理、软件包和具体软件包的系统配置文件和用户态配置文件的问题。对于前三者，我打算使用文档记录的方式来保留我的配置的信息，而对于用户态配置，我使用chezmoi配合Github上的私人仓库进行保存。

由此实现的在不断熵增的系统中的重点信息保留的能力，使得我即便重装系统，也应该可以靠文档和云文件、配置文件仓库等功能实现系统复现。这样，我认为“干净”的目的其实已经达到。因为干净本身不是最终的目的，尤其如前文所述在快速与高效的使用中，干净并不可能；干净带来的可控、可重建才是目的。可重建并不需要脚本化，保障信息的留存即可。

### 可重建目标下的系统包管理思维

包管理可以说是Linux系统使用中的一个核心的问题。甚至于可以说，Linux从一个内核到一个可用的发行版之间的过程就是一个合理的包管理方式。对于每个发行版，其包管理哲学往往是最能表现其个性的地方，但在实际使用中，用户又实际上不可能严格遵循完美的包管理设计。举例而言，在使用Wine或者rust与python编程时，往往需要不同版本的Wine环境、不同的rust编译器和不同的python环境，如果全部使用Arch Linux的滚动更新的包，则许多实际应用不能实现。此时，所使用的bottles、rustup、uv就是实际意义上的包管理器，只是它们在用户空间存储可执行文件。在用户空间管理可执行文件其实十分丑陋，但是对于现代系统的容器与沙箱需求而言，针对特定应用的专门包管理是有意义的，而只有在用户空间中可以实现这样的自由（换句话说，FHS的设计其实已经过时，从某种程度上Android与Nix才是真正的现代系统；但是同代诞生的snap与AppImage等又在时刻提醒人们忘记了KISS的哲学会有多么令人作呕的事情发生，让人不禁还是倾向于接受传统发行版的设计）。

另外一种包管理器是软件插件管理系统，比如说zsh对应的antigen、nvim对应的lazy。其实这些插件都可以由pacman管理；不过，为了快速试验与高效调整，使用这样的包管理方式也无可厚非。

对于以上两种包管理中一不小心就会创造出弗兰肯斯坦式的操作系统的使用方式而言，我的底线是，所有包管理器本身应该被pacman管理。比如，不应该使用curl安装lazy，而应该在系统全局使用pacman的相应PKGBUILD把lazy安装到/usr/share下。antigen、bottles、uv、rustup等也一样。

### 系统重建文档结构

- `meta.md`
    - 记录关于自己的GNU/Linux系统维护的指导思想与哲学思考
    - 记录按主题分类的Linux学习笔记
- `installation.md`
    - 记录一个系统从安装到系统配置与用户配置迁移的所有步骤
    - 允许分叉，针对不同情形的系统安装编写专门的步骤，比如安装双系统/单一系统可以有不同的选择
    - 必须记录详细的命令行指令，不能仅提供Arch Wiki链接
    - 应用的系统级别配置应当记录在这里
- `packages.md`
    - 分成两部分记录系统安装的软件包
        - 我的所有linux机器基本上需要包含的基础功能软件包
        - 针对特定功能可以选择性安装的软件包
    - 同时描述软件包的功能
- `usages.md`
    - 记录不同主题的常用功能命令和使用方法
    - 不局限与软件包，比如某种文件系统的相应用法

## GNU/Linux技术笔记

### 网络配置

### 键盘映射：从键码到输入

#### 内核与console

#### X与wayland

### Linux图形显示
